1. Какие типы паттернов проектирования существуют?

    Поведенческие Пораждающие Структурные

2. Как можно улучшить Singleton при помощи trait-ов?

    trait Singleton {
        private $instance;

        private __constructor {}
        private __clone {}
        private __wakeup {}

        public static getInstance() {
            if (!isset(self::$instance)) {
                self::$instance = new static;
            }
            return self::$instance;
        }
    }
    и использовать этот трейт в классах для которых нужен singleton.

3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?

    abstract class PaymentClass {
        // фабричный метод
        abstract public function getPayment(): Payment;

        public pay(): void {
            $this->getPayment();
            /*
            * бизнес логика из Payment для оплаты
            */
        }
    }

    // создатель 1
    class Payment1Pay extends PaymentClass {
        public function getPayment(): Payment {
            return new Payment1();
        }
    }

    // создатель 2
    class Payment2Pay extends PaymentClass {
        public function getPayment(): Payment {
            return new Payment2();
        }
    }

    interface Payment {
        /*
        * какие-то общие методы определяющие Payment
        */
    }

    class Payment1 implements Payment {
        /*
        * API для реализации первого способа оплаты
        */
    }

    class Payment2 implements Payment {
        /*
        * API для реализации второго способа оплаты
        */
    }

    Пример Payment1Pay() -> Pay();

    Фабричный метод предоставляет своим классам интерфейс с методом для определения экземпляров некоторого класса а
    фабрика предоставляет интерфейс для создания ряда взаимозависимых или взаимосвязанных объектов

4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic. Когда, как и почему их стоит использовать (или нет)?
    __get() - срабатывает когда идет попытка чтения из несуществующих или защищенных свойств
    __set() - срабатывает когда идет попытка записи в несуществующие или защищенные свойства
    __isset() - срабатывает когда идет использование isset() для несуществующих или защищенных свойств
    __unset() - срабатывает когда идет использование unset() для несуществующих или защищенных свойств
    __call() - срабатывает когда идет попытка вызова несуществующих или защищенных методов
    __callStatic - срабатывает когда идет попытка вызова несуществующих или защищенных статических методов

    Фактически можно использовать для динамического создания свойств и методов, но, насколько я знаю, это является плохой практикой.
    Однако в некоторых ситуациях может пригодится, например, если у нас есть единая точка входа в приложение(т.е. класс, реализованный через Singleton)
    и через нее идет создание других классов которые должны быть в единственном экзепляре в массиве,
    мы можем использовать __call() и подгружать нужные классы по мере вызова, например App()::сall()->NewClass(),
    где App()::call() будет вовзращать экземпляр App(), а попытка обратиться к несуществующему методу NewClass() вызовет __call(),
    запустит проверку есть ли класс в некотором массиве, в итоге либо создаст его либо вернёт уже созданный из массива.

5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.
    Библиотека SPL содержит следующие структуры данных:
        SplStack - Класс SplStack предоставляет основные функциональные возможности стека, реализованные с использованием двусвязного списка.
            $stack = new SplStack();
            $stack->push(25); // добавляем 1 в конец стека
            $stack->add(1,3); // добавляем на первую позицию 3
            echo $q->pop(); // 3
            echo $q->pop(); // 25

        SplFixedArray - Класс SplFixedArray обеспечивает базовую функциональность, предоставляемую массивами.
        Главное различие между SplFixedArray и обычным массивом PHP в том, что SplFixedArray имеет фиксированную длину,
        а в качестве индексов могут выступать только целочисленные значения. Преимущество данных ограничений заключается в меньшем использовании памяти,
        чем стандартный array.
            $array = new SplFixedArray(10);
            $array->setSize(5); // сокращаем длинну до 5
            foreach($array as $key=>$value) {
                $array[$key] = 1;
            }
            var_dump($array); // object(SplFixedArray)#1 (5) { [0]=> int(1) [1]=> int(1) [2]=> int(1) [3]=> int(1) [4]=> int(1) }

6. Найдите все ошибки в коде:

    interface MyInt {
        public function funcI();
        private function funcP();
    }
    class A {
        protected prop1;
        private prop2;

        function funcA(){
            return $this->prop2;
        }
    }
    class B extends A {
        function funcB(){
            return $this->prop1;
        }
    }
    class C extends B implements MyInt {
        function funcB(){
            return $this->prop1;
        }
        private function funcP(){
            return 123;
        }
    }
    $b = new B();
    $b->funcA();
    $c = new C();
    $c->funcI();

    1) class B наследуется от A и наследует функцию funcA() котрая использовала приватное поле prop2
    2) class C так же содержит ошибку выше, т.к наследуется от B
    3) в C мы переписываем funcB() на точно такую же
    4) funcP() приватная и не используется нигде в классе, к тому же возвращает просто число, что лучше оформить в виде константы
    5) в C отсутствует обязателный метод funcI() из интерефейса MyInt
    6) названия тут условные, поэтому за ошибку не считаю